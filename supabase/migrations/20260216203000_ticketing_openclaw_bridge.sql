-- F7: Ticketing end-to-end + OpenClaw bridge integration

-- =====================================================
-- 1) Core ticket tables
-- =====================================================
CREATE TABLE IF NOT EXISTS public.support_tickets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_number bigint GENERATED BY DEFAULT AS IDENTITY,
  ticket_id text GENERATED ALWAYS AS ('TKT-' || lpad(ticket_number::text, 8, '0')) STORED,
  hotel_id uuid NOT NULL REFERENCES public.hotels(id) ON DELETE CASCADE,
  title text NOT NULL CHECK (char_length(btrim(title)) BETWEEN 3 AND 240),
  description text NOT NULL DEFAULT '' CHECK (char_length(description) <= 8000),
  category text NOT NULL CHECK (category IN ('bug', 'soporte', 'incidente', 'mejora', 'operacion')),
  severity text NOT NULL DEFAULT 'medium' CHECK (severity IN ('low', 'medium', 'high', 'critical')),
  priority text NOT NULL DEFAULT 'P3' CHECK (priority IN ('P1', 'P2', 'P3', 'P4')),
  status text NOT NULL DEFAULT 'received' CHECK (status IN ('received', 'triaged', 'in_progress', 'blocked', 'fixed', 'needs_human', 'closed')),
  source text NOT NULL DEFAULT 'web' CHECK (source IN ('web', 'mobile', 'api', 'operations')),
  requester_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  requester_name text NOT NULL CHECK (char_length(btrim(requester_name)) BETWEEN 2 AND 120),
  assignee_user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  attachments jsonb NOT NULL DEFAULT '[]'::jsonb CHECK (jsonb_typeof(attachments) = 'array'),
  metadata jsonb NOT NULL DEFAULT '{}'::jsonb CHECK (jsonb_typeof(metadata) = 'object'),
  first_response_at timestamptz,
  resolved_at timestamptz,
  created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (ticket_number),
  UNIQUE (ticket_id)
);

CREATE INDEX IF NOT EXISTS idx_support_tickets_hotel_status_created
  ON public.support_tickets(hotel_id, status, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_tickets_hotel_severity_priority
  ON public.support_tickets(hotel_id, severity, priority, updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_tickets_hotel_dates
  ON public.support_tickets(hotel_id, created_at DESC, updated_at DESC);

CREATE TABLE IF NOT EXISTS public.support_ticket_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  hotel_id uuid NOT NULL REFERENCES public.hotels(id) ON DELETE CASCADE,
  ticket_id uuid NOT NULL REFERENCES public.support_tickets(id) ON DELETE CASCADE,
  event_id text NOT NULL,
  event_type text NOT NULL CHECK (
    event_type IN (
      'created',
      'updated',
      'status_changed',
      'assigned',
      'note',
      'closed',
      'reopened',
      'callback_received',
      'callback_processed',
      'callback_ignored',
      'dispatched',
      'dispatch_failed'
    )
  ),
  from_status text,
  to_status text,
  note text,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  actor_user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
  actor_name text,
  actor_type text NOT NULL DEFAULT 'user' CHECK (actor_type IN ('user', 'system', 'openclaw')),
  source text NOT NULL DEFAULT 'ui' CHECK (source IN ('ui', 'api', 'webhook', 'operations', 'system')),
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (event_id)
);

CREATE INDEX IF NOT EXISTS idx_support_ticket_events_ticket_created
  ON public.support_ticket_events(ticket_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_ticket_events_hotel_created
  ON public.support_ticket_events(hotel_id, created_at DESC);

CREATE TABLE IF NOT EXISTS public.support_ticket_outbox (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  hotel_id uuid NOT NULL REFERENCES public.hotels(id) ON DELETE CASCADE,
  ticket_id uuid NOT NULL REFERENCES public.support_tickets(id) ON DELETE CASCADE,
  event_id text NOT NULL,
  event_type text NOT NULL CHECK (event_type IN ('ticket.created', 'ticket.updated', 'ticket.escalated')),
  payload jsonb NOT NULL CHECK (jsonb_typeof(payload) = 'object'),
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'sent', 'failed')),
  attempt_count integer NOT NULL DEFAULT 0 CHECK (attempt_count >= 0),
  max_attempts integer NOT NULL DEFAULT 6 CHECK (max_attempts BETWEEN 1 AND 20),
  next_retry_at timestamptz NOT NULL DEFAULT now(),
  locked_at timestamptz,
  sent_at timestamptz,
  last_http_status integer,
  last_error text,
  request_id text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (event_id)
);

CREATE INDEX IF NOT EXISTS idx_support_ticket_outbox_status_retry
  ON public.support_ticket_outbox(status, next_retry_at);
CREATE INDEX IF NOT EXISTS idx_support_ticket_outbox_hotel_created
  ON public.support_ticket_outbox(hotel_id, created_at DESC);

CREATE TABLE IF NOT EXISTS public.support_ticket_inbox (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  hotel_id uuid NOT NULL REFERENCES public.hotels(id) ON DELETE CASCADE,
  ticket_id uuid REFERENCES public.support_tickets(id) ON DELETE SET NULL,
  event_id text NOT NULL,
  event_type text NOT NULL CHECK (
    event_type IN (
      'ticket.triaged',
      'ticket.analysis_ready',
      'ticket.solution_proposed',
      'ticket.resolved',
      'ticket.needs_human'
    )
  ),
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  status text NOT NULL DEFAULT 'received' CHECK (status IN ('received', 'processed', 'ignored', 'failed')),
  error text,
  request_id text,
  processed_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (event_id)
);

CREATE INDEX IF NOT EXISTS idx_support_ticket_inbox_hotel_created
  ON public.support_ticket_inbox(hotel_id, created_at DESC);

CREATE TABLE IF NOT EXISTS public.support_ticket_bridge_logs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  hotel_id uuid NOT NULL REFERENCES public.hotels(id) ON DELETE CASCADE,
  request_id text,
  event_id text,
  ticket_id uuid REFERENCES public.support_tickets(id) ON DELETE SET NULL,
  direction text NOT NULL CHECK (direction IN ('inbound', 'outbound')),
  event_type text NOT NULL,
  latency_ms integer,
  retries integer NOT NULL DEFAULT 0,
  result text NOT NULL CHECK (result IN ('success', 'error', 'ignored')),
  http_status integer,
  detail text,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_support_ticket_bridge_logs_hotel_created
  ON public.support_ticket_bridge_logs(hotel_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_support_ticket_bridge_logs_result
  ON public.support_ticket_bridge_logs(result, created_at DESC);

-- =====================================================
-- 2) Triggers and helper functions
-- =====================================================
CREATE OR REPLACE FUNCTION public.ticket_outbound_payload(_ticket public.support_tickets)
RETURNS jsonb
LANGUAGE sql
STABLE
AS $$
  SELECT jsonb_build_object(
    'ticket_id', _ticket.ticket_id,
    'ticket_uuid', _ticket.id,
    'title', _ticket.title,
    'description', _ticket.description,
    'category', _ticket.category,
    'severity', _ticket.severity,
    'priority', _ticket.priority,
    'status', _ticket.status,
    'source', _ticket.source,
    'requester_id', _ticket.requester_id,
    'requester_name', _ticket.requester_name,
    'assignee_user_id', _ticket.assignee_user_id,
    'hotel_id', _ticket.hotel_id,
    'attachments', _ticket.attachments,
    'metadata', _ticket.metadata,
    'first_response_at', _ticket.first_response_at,
    'resolved_at', _ticket.resolved_at,
    'created_at', _ticket.created_at,
    'updated_at', _ticket.updated_at
  );
$$;

CREATE OR REPLACE FUNCTION public.handle_support_ticket_before_write()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  NEW.title := btrim(coalesce(NEW.title, ''));
  NEW.description := coalesce(NEW.description, '');
  NEW.requester_name := btrim(coalesce(NEW.requester_name, ''));

  IF NEW.requester_name = '' THEN
    NEW.requester_name := 'Solicitante';
  END IF;

  IF NEW.requester_id IS NULL THEN
    NEW.requester_id := auth.uid();
  END IF;

  IF NEW.created_by IS NULL THEN
    NEW.created_by := auth.uid();
  END IF;

  IF NEW.attachments IS NULL OR jsonb_typeof(NEW.attachments) <> 'array' THEN
    NEW.attachments := '[]'::jsonb;
  END IF;

  IF NEW.metadata IS NULL OR jsonb_typeof(NEW.metadata) <> 'object' THEN
    NEW.metadata := '{}'::jsonb;
  END IF;

  IF TG_OP = 'UPDATE' AND NEW.status IS DISTINCT FROM OLD.status THEN
    IF NEW.first_response_at IS NULL AND NEW.status <> 'received' THEN
      NEW.first_response_at := now();
    END IF;

    IF NEW.status IN ('fixed', 'closed') THEN
      NEW.resolved_at := coalesce(NEW.resolved_at, now());
    ELSIF OLD.status IN ('fixed', 'closed') AND NEW.status NOT IN ('fixed', 'closed') THEN
      NEW.resolved_at := NULL;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.handle_support_ticket_after_write()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_now timestamptz := now();
  v_event_id text;
BEGIN
  IF TG_OP = 'INSERT' THEN
    v_event_id := 'tev_' || replace(gen_random_uuid()::text, '-', '');
    INSERT INTO public.support_ticket_events (
      hotel_id,
      ticket_id,
      event_id,
      event_type,
      note,
      payload,
      actor_user_id,
      actor_type,
      source,
      created_at
    ) VALUES (
      NEW.hotel_id,
      NEW.id,
      v_event_id,
      'created',
      'Ticket creado',
      jsonb_build_object('ticket_id', NEW.ticket_id),
      coalesce(NEW.created_by, auth.uid()),
      'user',
      CASE WHEN NEW.source = 'api' THEN 'api' ELSE 'ui' END,
      v_now
    );

    INSERT INTO public.support_ticket_outbox (
      hotel_id,
      ticket_id,
      event_id,
      event_type,
      payload,
      status,
      attempt_count,
      max_attempts,
      next_retry_at,
      created_at,
      updated_at
    ) VALUES (
      NEW.hotel_id,
      NEW.id,
      'toe_' || replace(gen_random_uuid()::text, '-', ''),
      'ticket.created',
      public.ticket_outbound_payload(NEW),
      'pending',
      0,
      6,
      v_now,
      v_now,
      v_now
    );

    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF NEW.status IS DISTINCT FROM OLD.status THEN
      INSERT INTO public.support_ticket_events (
        hotel_id,
        ticket_id,
        event_id,
        event_type,
        from_status,
        to_status,
        note,
        payload,
        actor_user_id,
        actor_type,
        source,
        created_at
      ) VALUES (
        NEW.hotel_id,
        NEW.id,
        'tev_' || replace(gen_random_uuid()::text, '-', ''),
        CASE
          WHEN NEW.status = 'closed' THEN 'closed'
          WHEN OLD.status = 'closed' AND NEW.status <> 'closed' THEN 'reopened'
          ELSE 'status_changed'
        END,
        OLD.status,
        NEW.status,
        concat('Estado: ', OLD.status, ' -> ', NEW.status),
        jsonb_build_object('from_status', OLD.status, 'to_status', NEW.status),
        auth.uid(),
        'user',
        'ui',
        v_now
      );
    END IF;

    IF NEW.assignee_user_id IS DISTINCT FROM OLD.assignee_user_id THEN
      INSERT INTO public.support_ticket_events (
        hotel_id,
        ticket_id,
        event_id,
        event_type,
        note,
        payload,
        actor_user_id,
        actor_type,
        source,
        created_at
      ) VALUES (
        NEW.hotel_id,
        NEW.id,
        'tev_' || replace(gen_random_uuid()::text, '-', ''),
        'assigned',
        'Responsable actualizado',
        jsonb_build_object('assignee_user_id', NEW.assignee_user_id),
        auth.uid(),
        'user',
        'ui',
        v_now
      );
    END IF;

    IF (
      NEW.title IS DISTINCT FROM OLD.title
      OR NEW.description IS DISTINCT FROM OLD.description
      OR NEW.category IS DISTINCT FROM OLD.category
      OR NEW.severity IS DISTINCT FROM OLD.severity
      OR NEW.priority IS DISTINCT FROM OLD.priority
      OR NEW.status IS DISTINCT FROM OLD.status
      OR NEW.source IS DISTINCT FROM OLD.source
      OR NEW.requester_name IS DISTINCT FROM OLD.requester_name
      OR NEW.assignee_user_id IS DISTINCT FROM OLD.assignee_user_id
      OR NEW.attachments IS DISTINCT FROM OLD.attachments
      OR NEW.metadata IS DISTINCT FROM OLD.metadata
    ) THEN
      INSERT INTO public.support_ticket_outbox (
        hotel_id,
        ticket_id,
        event_id,
        event_type,
        payload,
        status,
        attempt_count,
        max_attempts,
        next_retry_at,
        created_at,
        updated_at
      ) VALUES (
        NEW.hotel_id,
        NEW.id,
        'toe_' || replace(gen_random_uuid()::text, '-', ''),
        'ticket.updated',
        public.ticket_outbound_payload(NEW),
        'pending',
        0,
        6,
        v_now,
        v_now,
        v_now
      );
    END IF;

    IF (
      (OLD.severity <> 'critical' AND NEW.severity = 'critical')
      OR (OLD.priority <> 'P1' AND NEW.priority = 'P1')
      OR (OLD.status <> 'needs_human' AND NEW.status = 'needs_human')
    ) THEN
      INSERT INTO public.support_ticket_outbox (
        hotel_id,
        ticket_id,
        event_id,
        event_type,
        payload,
        status,
        attempt_count,
        max_attempts,
        next_retry_at,
        created_at,
        updated_at
      ) VALUES (
        NEW.hotel_id,
        NEW.id,
        'toe_' || replace(gen_random_uuid()::text, '-', ''),
        'ticket.escalated',
        public.ticket_outbound_payload(NEW),
        'pending',
        0,
        6,
        v_now,
        v_now,
        v_now
      );
    END IF;

    RETURN NEW;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_support_ticket_before_write ON public.support_tickets;
CREATE TRIGGER trg_support_ticket_before_write
BEFORE INSERT OR UPDATE ON public.support_tickets
FOR EACH ROW
EXECUTE FUNCTION public.handle_support_ticket_before_write();

DROP TRIGGER IF EXISTS set_support_tickets_updated_at ON public.support_tickets;
CREATE TRIGGER set_support_tickets_updated_at
BEFORE UPDATE ON public.support_tickets
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS trg_support_ticket_after_write ON public.support_tickets;
CREATE TRIGGER trg_support_ticket_after_write
AFTER INSERT OR UPDATE ON public.support_tickets
FOR EACH ROW
EXECUTE FUNCTION public.handle_support_ticket_after_write();

DROP TRIGGER IF EXISTS set_support_ticket_outbox_updated_at ON public.support_ticket_outbox;
CREATE TRIGGER set_support_ticket_outbox_updated_at
BEFORE UPDATE ON public.support_ticket_outbox
FOR EACH ROW
EXECUTE FUNCTION public.handle_updated_at();

-- =====================================================
-- 3) Views: metrics + bridge health
-- =====================================================
CREATE OR REPLACE VIEW public.support_ticket_metrics_view AS
WITH first_note AS (
  SELECT
    e.ticket_id,
    min(e.created_at) FILTER (
      WHERE e.event_type IN ('status_changed', 'assigned', 'note', 'callback_processed')
    ) AS first_response_at
  FROM public.support_ticket_events e
  GROUP BY e.ticket_id
),
resolution AS (
  SELECT
    t.id AS ticket_pk,
    CASE
      WHEN t.resolved_at IS NULL THEN NULL
      ELSE EXTRACT(EPOCH FROM (t.resolved_at - t.created_at)) / 60.0
    END AS resolution_minutes,
    CASE
      WHEN f.first_response_at IS NULL THEN NULL
      ELSE EXTRACT(EPOCH FROM (f.first_response_at - t.created_at)) / 60.0
    END AS first_response_minutes
  FROM public.support_tickets t
  LEFT JOIN first_note f ON f.ticket_id = t.id
),
severity_counts AS (
  SELECT
    base.hotel_id,
    jsonb_object_agg(base.severity, base.total) AS tickets_by_severity
  FROM (
    SELECT
      t.hotel_id,
      t.severity,
      count(*)::integer AS total
    FROM public.support_tickets t
    GROUP BY t.hotel_id, t.severity
  ) base
  GROUP BY base.hotel_id
),
status_counts AS (
  SELECT
    base.hotel_id,
    jsonb_object_agg(base.status, base.total) AS tickets_by_status
  FROM (
    SELECT
      t.hotel_id,
      t.status,
      count(*)::integer AS total
    FROM public.support_tickets t
    GROUP BY t.hotel_id, t.status
  ) base
  GROUP BY base.hotel_id
)
SELECT
  h.id AS hotel_id,
  count(*) FILTER (WHERE t.created_at >= date_trunc('day', now()))::integer AS tickets_created_today,
  round(avg(r.first_response_minutes)::numeric, 2) AS avg_first_response_minutes,
  round(avg(r.resolution_minutes)::numeric, 2) AS avg_resolution_minutes,
  coalesce(sc.tickets_by_severity, '{}'::jsonb) AS tickets_by_severity,
  coalesce(st.tickets_by_status, '{}'::jsonb) AS tickets_by_status
FROM public.hotels h
LEFT JOIN public.support_tickets t ON t.hotel_id = h.id
LEFT JOIN resolution r ON r.ticket_pk = t.id
LEFT JOIN severity_counts sc ON sc.hotel_id = h.id
LEFT JOIN status_counts st ON st.hotel_id = h.id
GROUP BY h.id, sc.tickets_by_severity, st.tickets_by_status;

CREATE OR REPLACE VIEW public.support_ticket_bridge_health_view AS
WITH outbound_recent AS (
  SELECT
    hotel_id,
    count(*) FILTER (WHERE result = 'success' AND direction = 'outbound')::integer AS success_count,
    count(*) FILTER (WHERE result = 'error' AND direction = 'outbound')::integer AS error_count,
    max(created_at) FILTER (WHERE result = 'success' AND direction = 'outbound') AS last_success_at,
    max(created_at) FILTER (WHERE result = 'error' AND direction = 'outbound') AS last_error_at
  FROM public.support_ticket_bridge_logs
  WHERE created_at >= now() - interval '30 minutes'
  GROUP BY hotel_id
),
outbox_pending AS (
  SELECT
    hotel_id,
    count(*) FILTER (WHERE status IN ('pending', 'failed') AND next_retry_at <= now())::integer AS pending_due,
    count(*) FILTER (WHERE status = 'failed')::integer AS failed_count
  FROM public.support_ticket_outbox
  GROUP BY hotel_id
)
SELECT
  h.id AS hotel_id,
  coalesce(o.success_count, 0) AS success_count_30m,
  coalesce(o.error_count, 0) AS error_count_30m,
  coalesce(p.pending_due, 0) AS pending_due,
  coalesce(p.failed_count, 0) AS failed_count,
  o.last_success_at,
  o.last_error_at,
  CASE
    WHEN coalesce(p.failed_count, 0) >= 10 THEN 'down'
    WHEN coalesce(p.pending_due, 0) >= 20 THEN 'down'
    WHEN coalesce(o.error_count, 0) > 0 AND coalesce(o.success_count, 0) = 0 THEN 'degraded'
    WHEN coalesce(p.pending_due, 0) >= 5 THEN 'degraded'
    ELSE 'up'
  END AS bridge_status
FROM public.hotels h
LEFT JOIN outbound_recent o ON o.hotel_id = h.id
LEFT JOIN outbox_pending p ON p.hotel_id = h.id;

GRANT SELECT ON public.support_ticket_metrics_view TO authenticated;
GRANT SELECT ON public.support_ticket_bridge_health_view TO authenticated;

-- =====================================================
-- 4) RLS policies
-- =====================================================
ALTER TABLE public.support_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_ticket_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_ticket_outbox ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_ticket_inbox ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.support_ticket_bridge_logs ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Hotel staff can view support tickets" ON public.support_tickets;
CREATE POLICY "Hotel staff can view support tickets"
ON public.support_tickets
FOR SELECT
TO authenticated
USING (
  hotel_id = public.get_user_hotel_id()
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel staff can create support tickets" ON public.support_tickets;
CREATE POLICY "Hotel staff can create support tickets"
ON public.support_tickets
FOR INSERT
TO authenticated
WITH CHECK (
  hotel_id = public.get_user_hotel_id()
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel staff can update support tickets" ON public.support_tickets;
CREATE POLICY "Hotel staff can update support tickets"
ON public.support_tickets
FOR UPDATE
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_maitre()
    OR public.is_rrhh()
    OR requester_id = auth.uid()
  ))
  OR public.is_super_admin()
)
WITH CHECK (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_maitre()
    OR public.is_rrhh()
    OR requester_id = auth.uid()
  ))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel management can delete support tickets" ON public.support_tickets;
CREATE POLICY "Hotel management can delete support tickets"
ON public.support_tickets
FOR DELETE
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (public.has_management_access() OR public.is_super_admin()))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel staff can view support ticket events" ON public.support_ticket_events;
CREATE POLICY "Hotel staff can view support ticket events"
ON public.support_ticket_events
FOR SELECT
TO authenticated
USING (
  hotel_id = public.get_user_hotel_id()
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel staff can insert support ticket events" ON public.support_ticket_events;
CREATE POLICY "Hotel staff can insert support ticket events"
ON public.support_ticket_events
FOR INSERT
TO authenticated
WITH CHECK (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_maitre()
    OR public.is_rrhh()
  ))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel management can delete support ticket events" ON public.support_ticket_events;
CREATE POLICY "Hotel management can delete support ticket events"
ON public.support_ticket_events
FOR DELETE
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (public.has_management_access() OR public.is_super_admin()))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Hotel ops can view support outbox" ON public.support_ticket_outbox;
CREATE POLICY "Hotel ops can view support outbox"
ON public.support_ticket_outbox
FOR SELECT
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_rrhh()
    OR public.is_super_admin()
  ))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Super admins can manage support outbox" ON public.support_ticket_outbox;
CREATE POLICY "Super admins can manage support outbox"
ON public.support_ticket_outbox
FOR ALL
TO authenticated
USING (public.is_super_admin())
WITH CHECK (public.is_super_admin());

DROP POLICY IF EXISTS "Hotel ops can view support inbox" ON public.support_ticket_inbox;
CREATE POLICY "Hotel ops can view support inbox"
ON public.support_ticket_inbox
FOR SELECT
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_rrhh()
    OR public.is_super_admin()
  ))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Super admins can manage support inbox" ON public.support_ticket_inbox;
CREATE POLICY "Super admins can manage support inbox"
ON public.support_ticket_inbox
FOR ALL
TO authenticated
USING (public.is_super_admin())
WITH CHECK (public.is_super_admin());

DROP POLICY IF EXISTS "Hotel ops can view support bridge logs" ON public.support_ticket_bridge_logs;
CREATE POLICY "Hotel ops can view support bridge logs"
ON public.support_ticket_bridge_logs
FOR SELECT
TO authenticated
USING (
  (hotel_id = public.get_user_hotel_id() AND (
    public.has_management_access()
    OR public.is_produccion()
    OR public.is_rrhh()
    OR public.is_super_admin()
  ))
  OR public.is_super_admin()
);

DROP POLICY IF EXISTS "Super admins can manage support bridge logs" ON public.support_ticket_bridge_logs;
CREATE POLICY "Super admins can manage support bridge logs"
ON public.support_ticket_bridge_logs
FOR ALL
TO authenticated
USING (public.is_super_admin())
WITH CHECK (public.is_super_admin());
